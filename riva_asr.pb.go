// SPDX-FileCopyrightText: Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
// SPDX-License-Identifier: MIT

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.5
// 	protoc        v5.29.2
// source: riva/proto/riva_asr.proto

package riva_speech

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RivaSpeechRecognitionConfigRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If model is specified only return config for model, otherwise return all
	// configs.
	ModelName     string `protobuf:"bytes,1,opt,name=model_name,json=modelName,proto3" json:"model_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RivaSpeechRecognitionConfigRequest) Reset() {
	*x = RivaSpeechRecognitionConfigRequest{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RivaSpeechRecognitionConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RivaSpeechRecognitionConfigRequest) ProtoMessage() {}

func (x *RivaSpeechRecognitionConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RivaSpeechRecognitionConfigRequest.ProtoReflect.Descriptor instead.
func (*RivaSpeechRecognitionConfigRequest) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{0}
}

func (x *RivaSpeechRecognitionConfigRequest) GetModelName() string {
	if x != nil {
		return x.ModelName
	}
	return ""
}

type RivaSpeechRecognitionConfigResponse struct {
	state         protoimpl.MessageState                        `protogen:"open.v1"`
	ModelConfig   []*RivaSpeechRecognitionConfigResponse_Config `protobuf:"bytes,1,rep,name=model_config,json=modelConfig,proto3" json:"model_config,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RivaSpeechRecognitionConfigResponse) Reset() {
	*x = RivaSpeechRecognitionConfigResponse{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RivaSpeechRecognitionConfigResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RivaSpeechRecognitionConfigResponse) ProtoMessage() {}

func (x *RivaSpeechRecognitionConfigResponse) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RivaSpeechRecognitionConfigResponse.ProtoReflect.Descriptor instead.
func (*RivaSpeechRecognitionConfigResponse) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{1}
}

func (x *RivaSpeechRecognitionConfigResponse) GetModelConfig() []*RivaSpeechRecognitionConfigResponse_Config {
	if x != nil {
		return x.ModelConfig
	}
	return nil
}

// RecognizeRequest is used for batch processing of a single audio recording.
type RecognizeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Provides information to recognizer that specifies how to process the
	// request.
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	// The raw audio data to be processed. The audio bytes must be encoded as
	// specified in `RecognitionConfig`.
	Audio []byte `protobuf:"bytes,2,opt,name=audio,proto3" json:"audio,omitempty"`
	// The ID to be associated with the request. If provided, this will be
	// returned in the corresponding response.
	Id            *RequestId `protobuf:"bytes,100,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecognizeRequest) Reset() {
	*x = RecognizeRequest{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecognizeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognizeRequest) ProtoMessage() {}

func (x *RecognizeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognizeRequest.ProtoReflect.Descriptor instead.
func (*RecognizeRequest) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{2}
}

func (x *RecognizeRequest) GetConfig() *RecognitionConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *RecognizeRequest) GetAudio() []byte {
	if x != nil {
		return x.Audio
	}
	return nil
}

func (x *RecognizeRequest) GetId() *RequestId {
	if x != nil {
		return x.Id
	}
	return nil
}

// A StreamingRecognizeRequest is used to configure and stream audio content to
// the Riva ASR Service. The first message sent must include only a
// StreamingRecognitionConfig. Subsequent messages sent in the stream must
// contain only raw bytes of the audio to be recognized.
type StreamingRecognizeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The streaming request, which is either a streaming config or audio content.
	//
	// Types that are valid to be assigned to StreamingRequest:
	//
	//	*StreamingRecognizeRequest_StreamingConfig
	//	*StreamingRecognizeRequest_AudioContent
	StreamingRequest isStreamingRecognizeRequest_StreamingRequest `protobuf_oneof:"streaming_request"`
	// The ID to be associated with the request. If provided, this will be
	// returned in the corresponding responses.
	Id            *RequestId `protobuf:"bytes,100,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamingRecognizeRequest) Reset() {
	*x = StreamingRecognizeRequest{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamingRecognizeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamingRecognizeRequest) ProtoMessage() {}

func (x *StreamingRecognizeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamingRecognizeRequest.ProtoReflect.Descriptor instead.
func (*StreamingRecognizeRequest) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{3}
}

func (x *StreamingRecognizeRequest) GetStreamingRequest() isStreamingRecognizeRequest_StreamingRequest {
	if x != nil {
		return x.StreamingRequest
	}
	return nil
}

func (x *StreamingRecognizeRequest) GetStreamingConfig() *StreamingRecognitionConfig {
	if x != nil {
		if x, ok := x.StreamingRequest.(*StreamingRecognizeRequest_StreamingConfig); ok {
			return x.StreamingConfig
		}
	}
	return nil
}

func (x *StreamingRecognizeRequest) GetAudioContent() []byte {
	if x != nil {
		if x, ok := x.StreamingRequest.(*StreamingRecognizeRequest_AudioContent); ok {
			return x.AudioContent
		}
	}
	return nil
}

func (x *StreamingRecognizeRequest) GetId() *RequestId {
	if x != nil {
		return x.Id
	}
	return nil
}

type isStreamingRecognizeRequest_StreamingRequest interface {
	isStreamingRecognizeRequest_StreamingRequest()
}

type StreamingRecognizeRequest_StreamingConfig struct {
	// Provides information to the recognizer that specifies how to process the
	// request. The first `StreamingRecognizeRequest` message must contain a
	// `streaming_config`  message.
	StreamingConfig *StreamingRecognitionConfig `protobuf:"bytes,1,opt,name=streaming_config,json=streamingConfig,proto3,oneof"`
}

type StreamingRecognizeRequest_AudioContent struct {
	// The audio data to be recognized. Sequential chunks of audio data are sent
	// in sequential `StreamingRecognizeRequest` messages. The first
	// `StreamingRecognizeRequest` message must not contain `audio` data
	// and all subsequent `StreamingRecognizeRequest` messages must contain
	// `audio` data. The audio bytes must be encoded as specified in
	// `RecognitionConfig`.
	AudioContent []byte `protobuf:"bytes,2,opt,name=audio_content,json=audioContent,proto3,oneof"`
}

func (*StreamingRecognizeRequest_StreamingConfig) isStreamingRecognizeRequest_StreamingRequest() {}

func (*StreamingRecognizeRequest_AudioContent) isStreamingRecognizeRequest_StreamingRequest() {}

// EndpointingConfig is used for configuring different fields related to start
// or end of utterance
type EndpointingConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// `start_history` is the size of the window, in milliseconds, used to
	// detect start of utterance.
	// `start_threshold` is the percentage threshold used to detect start of
	// utterance. (0.0 to 1.0)
	// If `start_threshold` of `start_history` ms of the acoustic model output
	// have non-blank tokens, start of utterance is detected.
	StartHistory   *int32   `protobuf:"varint,1,opt,name=start_history,json=startHistory,proto3,oneof" json:"start_history,omitempty"`
	StartThreshold *float32 `protobuf:"fixed32,2,opt,name=start_threshold,json=startThreshold,proto3,oneof" json:"start_threshold,omitempty"`
	// `stop_history` is the size of the window, in milliseconds, used to
	// detect end of utterance.
	// `stop_threshold` is the percentage threshold used to detect end of
	// utterance. (0.0 to 1.0)
	// If `stop_threshold` of `stop_history` ms of the acoustic model output have
	// non-blank tokens, end of utterance is detected and decoder will be reset.
	StopHistory   *int32   `protobuf:"varint,3,opt,name=stop_history,json=stopHistory,proto3,oneof" json:"stop_history,omitempty"`
	StopThreshold *float32 `protobuf:"fixed32,4,opt,name=stop_threshold,json=stopThreshold,proto3,oneof" json:"stop_threshold,omitempty"`
	// `stop_history_eou` and `stop_threshold_eou` are used for 2-pass end of utterance.
	// `stop_history_eou` is the size of the window, in milliseconds, used to
	// trigger 1st pass of end of utterance and generate a partial transcript
	// with stability of 1. (stop_history_eou < stop_history)
	// `stop_threshold_eou` is the percentage threshold used to trigger 1st
	// pass of end of utterance. (0.0 to 1.0)
	// If `stop_threshold_eou` of `stop_history_eou` ms of the acoustic model
	// output have non-blank tokens, 1st pass of end of utterance is triggered.
	StopHistoryEou   *int32   `protobuf:"varint,5,opt,name=stop_history_eou,json=stopHistoryEou,proto3,oneof" json:"stop_history_eou,omitempty"`
	StopThresholdEou *float32 `protobuf:"fixed32,6,opt,name=stop_threshold_eou,json=stopThresholdEou,proto3,oneof" json:"stop_threshold_eou,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *EndpointingConfig) Reset() {
	*x = EndpointingConfig{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointingConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointingConfig) ProtoMessage() {}

func (x *EndpointingConfig) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointingConfig.ProtoReflect.Descriptor instead.
func (*EndpointingConfig) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{4}
}

func (x *EndpointingConfig) GetStartHistory() int32 {
	if x != nil && x.StartHistory != nil {
		return *x.StartHistory
	}
	return 0
}

func (x *EndpointingConfig) GetStartThreshold() float32 {
	if x != nil && x.StartThreshold != nil {
		return *x.StartThreshold
	}
	return 0
}

func (x *EndpointingConfig) GetStopHistory() int32 {
	if x != nil && x.StopHistory != nil {
		return *x.StopHistory
	}
	return 0
}

func (x *EndpointingConfig) GetStopThreshold() float32 {
	if x != nil && x.StopThreshold != nil {
		return *x.StopThreshold
	}
	return 0
}

func (x *EndpointingConfig) GetStopHistoryEou() int32 {
	if x != nil && x.StopHistoryEou != nil {
		return *x.StopHistoryEou
	}
	return 0
}

func (x *EndpointingConfig) GetStopThresholdEou() float32 {
	if x != nil && x.StopThresholdEou != nil {
		return *x.StopThresholdEou
	}
	return 0
}

// Provides information to the recognizer that specifies how to process the
// request
type RecognitionConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The encoding of the audio data sent in the request.
	//
	// All encodings support only 1 channel (mono) audio.
	Encoding AudioEncoding `protobuf:"varint,1,opt,name=encoding,proto3,enum=nvidia.riva.AudioEncoding" json:"encoding,omitempty"`
	//	The sample rate in hertz (Hz) of the audio data sent in the
	//
	// `RecognizeRequest` or `StreamingRecognizeRequest` messages.
	//
	//	The Riva server will automatically down-sample/up-sample the audio to
	//	match the ASR acoustic model sample rate. The sample rate value below 8kHz
	//	will not produce any meaningful output.
	SampleRateHertz int32 `protobuf:"varint,2,opt,name=sample_rate_hertz,json=sampleRateHertz,proto3" json:"sample_rate_hertz,omitempty"`
	// Required. The language of the supplied audio as a
	// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag.
	// Example: "en-US".
	LanguageCode string `protobuf:"bytes,3,opt,name=language_code,json=languageCode,proto3" json:"language_code,omitempty"`
	// Maximum number of recognition hypotheses to be returned.
	// Specifically, the maximum number of `SpeechRecognizeAlternative` messages
	// within each `SpeechRecognizeResult`.
	// The server may return fewer than `max_alternatives`.
	// If omitted, will return a maximum of one.
	MaxAlternatives int32 `protobuf:"varint,4,opt,name=max_alternatives,json=maxAlternatives,proto3" json:"max_alternatives,omitempty"`
	// A custom field that enables profanity filtering for the generated
	// transcripts. If set to 'true', the server filters out profanities,
	// replacing all but the initial character in each filtered word with
	// asterisks. For example, "x**". If set to `false` or omitted, profanities
	// will not be filtered out. The default is `false`.
	ProfanityFilter bool `protobuf:"varint,5,opt,name=profanity_filter,json=profanityFilter,proto3" json:"profanity_filter,omitempty"`
	// Array of SpeechContext.
	// A means to provide context to assist the speech recognition. For more
	// information, see SpeechContext section
	SpeechContexts []*SpeechContext `protobuf:"bytes,6,rep,name=speech_contexts,json=speechContexts,proto3" json:"speech_contexts,omitempty"`
	// The number of channels in the input audio data.
	// If `0` or omitted, defaults to one channel (mono).
	// Note: Only single channel audio input is supported as of now.
	AudioChannelCount int32 `protobuf:"varint,7,opt,name=audio_channel_count,json=audioChannelCount,proto3" json:"audio_channel_count,omitempty"`
	// If `true`, the top result includes a list of words and the start and end
	// time offsets (timestamps), and confidence scores for those words. If
	// `false`, no word-level time offset information is returned. The default
	// is `false`.
	EnableWordTimeOffsets bool `protobuf:"varint,8,opt,name=enable_word_time_offsets,json=enableWordTimeOffsets,proto3" json:"enable_word_time_offsets,omitempty"`
	// If 'true', adds punctuation to recognition result hypotheses. The
	// default 'false' value does not add punctuation to result hypotheses.
	EnableAutomaticPunctuation bool `protobuf:"varint,11,opt,name=enable_automatic_punctuation,json=enableAutomaticPunctuation,proto3" json:"enable_automatic_punctuation,omitempty"`
	// This needs to be set to `true` explicitly and `audio_channel_count` > 1
	// to get each channel recognized separately. The recognition result will
	// contain a `channel_tag` field to state which channel that result belongs
	// to. If this is not true, we will only recognize the first channel. The
	// request is billed cumulatively for all channels recognized:
	// `audio_channel_count` multiplied by the length of the audio.
	// Note: This field is not yet supported.
	EnableSeparateRecognitionPerChannel bool `protobuf:"varint,12,opt,name=enable_separate_recognition_per_channel,json=enableSeparateRecognitionPerChannel,proto3" json:"enable_separate_recognition_per_channel,omitempty"`
	// Which model to select for the given request.
	// If empty, Riva will select the right model based on the other
	// RecognitionConfig parameters. The model should correspond to the name
	// passed to `riva-build` with the `--name` argument
	Model string `protobuf:"bytes,13,opt,name=model,proto3" json:"model,omitempty"`
	// The verbatim_transcripts flag enables or disable inverse text
	// normalization. 'true' returns exactly what was said, with no
	// denormalization. 'false' applies inverse text normalization, also this is
	// the default
	VerbatimTranscripts bool `protobuf:"varint,14,opt,name=verbatim_transcripts,json=verbatimTranscripts,proto3" json:"verbatim_transcripts,omitempty"`
	// Config to enable speaker diarization and set additional
	// parameters. For non-streaming requests, the diarization results will be
	// provided only in the top alternative of the FINAL SpeechRecognitionResult.
	DiarizationConfig *SpeakerDiarizationConfig `protobuf:"bytes,19,opt,name=diarization_config,json=diarizationConfig,proto3" json:"diarization_config,omitempty"`
	// Custom fields for passing request-level
	// configuration options to plugins used in the
	// model pipeline.
	CustomConfiguration map[string]string `protobuf:"bytes,24,rep,name=custom_configuration,json=customConfiguration,proto3" json:"custom_configuration,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Config for tuning start or end of utterance parameters.
	// If empty, Riva will use default values or custom values if specified in riva-build arguments.
	EndpointingConfig *EndpointingConfig `protobuf:"bytes,25,opt,name=endpointing_config,json=endpointingConfig,proto3,oneof" json:"endpointing_config,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *RecognitionConfig) Reset() {
	*x = RecognitionConfig{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecognitionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognitionConfig) ProtoMessage() {}

func (x *RecognitionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognitionConfig.ProtoReflect.Descriptor instead.
func (*RecognitionConfig) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{5}
}

func (x *RecognitionConfig) GetEncoding() AudioEncoding {
	if x != nil {
		return x.Encoding
	}
	return AudioEncoding_ENCODING_UNSPECIFIED
}

func (x *RecognitionConfig) GetSampleRateHertz() int32 {
	if x != nil {
		return x.SampleRateHertz
	}
	return 0
}

func (x *RecognitionConfig) GetLanguageCode() string {
	if x != nil {
		return x.LanguageCode
	}
	return ""
}

func (x *RecognitionConfig) GetMaxAlternatives() int32 {
	if x != nil {
		return x.MaxAlternatives
	}
	return 0
}

func (x *RecognitionConfig) GetProfanityFilter() bool {
	if x != nil {
		return x.ProfanityFilter
	}
	return false
}

func (x *RecognitionConfig) GetSpeechContexts() []*SpeechContext {
	if x != nil {
		return x.SpeechContexts
	}
	return nil
}

func (x *RecognitionConfig) GetAudioChannelCount() int32 {
	if x != nil {
		return x.AudioChannelCount
	}
	return 0
}

func (x *RecognitionConfig) GetEnableWordTimeOffsets() bool {
	if x != nil {
		return x.EnableWordTimeOffsets
	}
	return false
}

func (x *RecognitionConfig) GetEnableAutomaticPunctuation() bool {
	if x != nil {
		return x.EnableAutomaticPunctuation
	}
	return false
}

func (x *RecognitionConfig) GetEnableSeparateRecognitionPerChannel() bool {
	if x != nil {
		return x.EnableSeparateRecognitionPerChannel
	}
	return false
}

func (x *RecognitionConfig) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *RecognitionConfig) GetVerbatimTranscripts() bool {
	if x != nil {
		return x.VerbatimTranscripts
	}
	return false
}

func (x *RecognitionConfig) GetDiarizationConfig() *SpeakerDiarizationConfig {
	if x != nil {
		return x.DiarizationConfig
	}
	return nil
}

func (x *RecognitionConfig) GetCustomConfiguration() map[string]string {
	if x != nil {
		return x.CustomConfiguration
	}
	return nil
}

func (x *RecognitionConfig) GetEndpointingConfig() *EndpointingConfig {
	if x != nil {
		return x.EndpointingConfig
	}
	return nil
}

// Provides information to the recognizer that specifies how to process the
// request
type StreamingRecognitionConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Provides information to the recognizer that specifies how to process the
	// request
	Config *RecognitionConfig `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	// If `true`, interim results (tentative hypotheses) may be
	// returned as they become available (these interim results are indicated with
	// the `is_final=false` flag).
	// If `false` or omitted, only `is_final=true` result(s) are returned.
	InterimResults bool `protobuf:"varint,2,opt,name=interim_results,json=interimResults,proto3" json:"interim_results,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StreamingRecognitionConfig) Reset() {
	*x = StreamingRecognitionConfig{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamingRecognitionConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamingRecognitionConfig) ProtoMessage() {}

func (x *StreamingRecognitionConfig) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamingRecognitionConfig.ProtoReflect.Descriptor instead.
func (*StreamingRecognitionConfig) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{6}
}

func (x *StreamingRecognitionConfig) GetConfig() *RecognitionConfig {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *StreamingRecognitionConfig) GetInterimResults() bool {
	if x != nil {
		return x.InterimResults
	}
	return false
}

// Config to enable speaker diarization.
type SpeakerDiarizationConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If 'true', enables speaker detection for each recognized word in
	// the top alternative of the recognition result using a speaker_tag provided
	// in the WordInfo.
	EnableSpeakerDiarization bool `protobuf:"varint,1,opt,name=enable_speaker_diarization,json=enableSpeakerDiarization,proto3" json:"enable_speaker_diarization,omitempty"`
	// Maximum number of speakers in the conversation. This gives flexibility by
	// allowing the system to automatically determine the correct number of
	// speakers. If not set, the default value is 8.
	MaxSpeakerCount int32 `protobuf:"varint,2,opt,name=max_speaker_count,json=maxSpeakerCount,proto3" json:"max_speaker_count,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SpeakerDiarizationConfig) Reset() {
	*x = SpeakerDiarizationConfig{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpeakerDiarizationConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpeakerDiarizationConfig) ProtoMessage() {}

func (x *SpeakerDiarizationConfig) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpeakerDiarizationConfig.ProtoReflect.Descriptor instead.
func (*SpeakerDiarizationConfig) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{7}
}

func (x *SpeakerDiarizationConfig) GetEnableSpeakerDiarization() bool {
	if x != nil {
		return x.EnableSpeakerDiarization
	}
	return false
}

func (x *SpeakerDiarizationConfig) GetMaxSpeakerCount() int32 {
	if x != nil {
		return x.MaxSpeakerCount
	}
	return 0
}

// Provides "hints" to the speech recognizer to favor specific words and phrases
// in the results.
type SpeechContext struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of strings containing words and phrases "hints" so that
	// the speech recognition is more likely to recognize them. This can be used
	// to improve the accuracy for specific words and phrases, for example, if
	// specific commands are typically spoken by the user. This can also be used
	// to add additional words to the vocabulary of the recognizer.
	Phrases []string `protobuf:"bytes,1,rep,name=phrases,proto3" json:"phrases,omitempty"`
	// Hint Boost. Positive value will increase the probability that a specific
	// phrase will be recognized over other similar sounding phrases. The higher
	// the boost, the higher the chance of false positive recognition as well.
	// Though `boost` can accept a wide range of positive values, most use cases
	// are best served with values between 0 and 20. We recommend using a binary
	// search approach to finding the optimal value for your use case.
	Boost         float32 `protobuf:"fixed32,4,opt,name=boost,proto3" json:"boost,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpeechContext) Reset() {
	*x = SpeechContext{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpeechContext) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpeechContext) ProtoMessage() {}

func (x *SpeechContext) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpeechContext.ProtoReflect.Descriptor instead.
func (*SpeechContext) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{8}
}

func (x *SpeechContext) GetPhrases() []string {
	if x != nil {
		return x.Phrases
	}
	return nil
}

func (x *SpeechContext) GetBoost() float32 {
	if x != nil {
		return x.Boost
	}
	return 0
}

// The only message returned to the client by the `Recognize` method. It
// contains the result as zero or more sequential `SpeechRecognitionResult`
// messages.
type RecognizeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Sequential list of transcription results corresponding to
	// sequential portions of audio. Currently only returns one transcript.
	Results []*SpeechRecognitionResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	// The ID associated with the request
	Id            *RequestId `protobuf:"bytes,100,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecognizeResponse) Reset() {
	*x = RecognizeResponse{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecognizeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecognizeResponse) ProtoMessage() {}

func (x *RecognizeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecognizeResponse.ProtoReflect.Descriptor instead.
func (*RecognizeResponse) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{9}
}

func (x *RecognizeResponse) GetResults() []*SpeechRecognitionResult {
	if x != nil {
		return x.Results
	}
	return nil
}

func (x *RecognizeResponse) GetId() *RequestId {
	if x != nil {
		return x.Id
	}
	return nil
}

// A speech recognition result corresponding to the latest transcript
type SpeechRecognitionResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// May contain one or more recognition hypotheses (up to the
	// maximum specified in `max_alternatives`).
	// These alternatives are ordered in terms of accuracy, with the top (first)
	// alternative being the most probable, as ranked by the recognizer.
	Alternatives []*SpeechRecognitionAlternative `protobuf:"bytes,1,rep,name=alternatives,proto3" json:"alternatives,omitempty"`
	// For multi-channel audio, this is the channel number corresponding to the
	// recognized result for the audio from that channel.
	// For audio_channel_count = N, its output values can range from '1' to 'N'.
	ChannelTag int32 `protobuf:"varint,2,opt,name=channel_tag,json=channelTag,proto3" json:"channel_tag,omitempty"`
	// Length of audio processed so far in seconds
	AudioProcessed float32 `protobuf:"fixed32,3,opt,name=audio_processed,json=audioProcessed,proto3" json:"audio_processed,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SpeechRecognitionResult) Reset() {
	*x = SpeechRecognitionResult{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpeechRecognitionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpeechRecognitionResult) ProtoMessage() {}

func (x *SpeechRecognitionResult) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpeechRecognitionResult.ProtoReflect.Descriptor instead.
func (*SpeechRecognitionResult) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{10}
}

func (x *SpeechRecognitionResult) GetAlternatives() []*SpeechRecognitionAlternative {
	if x != nil {
		return x.Alternatives
	}
	return nil
}

func (x *SpeechRecognitionResult) GetChannelTag() int32 {
	if x != nil {
		return x.ChannelTag
	}
	return 0
}

func (x *SpeechRecognitionResult) GetAudioProcessed() float32 {
	if x != nil {
		return x.AudioProcessed
	}
	return 0
}

// Alternative hypotheses (a.k.a. n-best list).
type SpeechRecognitionAlternative struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Transcript text representing the words that the user spoke.
	Transcript string `protobuf:"bytes,1,opt,name=transcript,proto3" json:"transcript,omitempty"`
	// The confidence estimate. A higher number indicates an estimated greater
	// likelihood that the recognized word is correct. This field is set only for
	// a non-streaming result or, for a streaming result where is_final=true.
	// This field is not guaranteed to be accurate and users should not rely on
	// it to be always provided. Although confidence can currently be roughly
	// interpreted as a natural-log probability, the estimate computation varies
	// with difference configurations, and is subject to change. The default of
	// 0.0 is a sentinel value indicating confidence was not set.
	Confidence float32 `protobuf:"fixed32,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// A list of word-specific information for each recognized word. Only
	// populated if is_final=true
	Words         []*WordInfo `protobuf:"bytes,3,rep,name=words,proto3" json:"words,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SpeechRecognitionAlternative) Reset() {
	*x = SpeechRecognitionAlternative{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SpeechRecognitionAlternative) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SpeechRecognitionAlternative) ProtoMessage() {}

func (x *SpeechRecognitionAlternative) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SpeechRecognitionAlternative.ProtoReflect.Descriptor instead.
func (*SpeechRecognitionAlternative) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{11}
}

func (x *SpeechRecognitionAlternative) GetTranscript() string {
	if x != nil {
		return x.Transcript
	}
	return ""
}

func (x *SpeechRecognitionAlternative) GetConfidence() float32 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *SpeechRecognitionAlternative) GetWords() []*WordInfo {
	if x != nil {
		return x.Words
	}
	return nil
}

// Word-specific information for recognized words.
type WordInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Time offset relative to the beginning of the audio in ms
	// and corresponding to the start of the spoken word.
	// This field is only set if `enable_word_time_offsets=true` and only
	// in the top hypothesis.
	StartTime int32 `protobuf:"varint,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Time offset relative to the beginning of the audio in ms
	// and corresponding to the end of the spoken word.
	// This field is only set if `enable_word_time_offsets=true` and only
	// in the top hypothesis.
	EndTime int32 `protobuf:"varint,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// The word corresponding to this set of information.
	Word string `protobuf:"bytes,3,opt,name=word,proto3" json:"word,omitempty"`
	// The confidence estimate. A higher number indicates an estimated greater
	// likelihood that the recognized word is correct. This field is set only for
	// a non-streaming result or, for a streaming result where is_final=true.
	// This field is not guaranteed to be accurate and users should not rely on
	// it to be always provided. Although confidence can currently be roughly
	// interpreted as a natural-log probability, the estimate computation varies
	// with difference configurations, and is subject to change. The default of
	// 0.0 is a sentinel value indicating confidence was not set.
	Confidence float32 `protobuf:"fixed32,4,opt,name=confidence,proto3" json:"confidence,omitempty"`
	// Output only. A distinct integer value is assigned for every speaker within
	// the audio. This field specifies which one of those speakers was detected to
	// have spoken this word. Value ranges from '1' to diarization_speaker_count.
	// speaker_tag is set if enable_speaker_diarization = 'true' and only in the
	// top alternative.
	SpeakerTag    int32 `protobuf:"varint,5,opt,name=speaker_tag,json=speakerTag,proto3" json:"speaker_tag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WordInfo) Reset() {
	*x = WordInfo{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WordInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WordInfo) ProtoMessage() {}

func (x *WordInfo) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WordInfo.ProtoReflect.Descriptor instead.
func (*WordInfo) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{12}
}

func (x *WordInfo) GetStartTime() int32 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *WordInfo) GetEndTime() int32 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *WordInfo) GetWord() string {
	if x != nil {
		return x.Word
	}
	return ""
}

func (x *WordInfo) GetConfidence() float32 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *WordInfo) GetSpeakerTag() int32 {
	if x != nil {
		return x.SpeakerTag
	}
	return 0
}

type StreamingRecognizeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This repeated list contains the latest transcript(s) corresponding to
	// audio currently being processed.
	// Currently one result is returned, where each result can have multiple
	// alternatives
	Results []*StreamingRecognitionResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	// The ID associated with the request
	Id            *RequestId `protobuf:"bytes,100,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StreamingRecognizeResponse) Reset() {
	*x = StreamingRecognizeResponse{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamingRecognizeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamingRecognizeResponse) ProtoMessage() {}

func (x *StreamingRecognizeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamingRecognizeResponse.ProtoReflect.Descriptor instead.
func (*StreamingRecognizeResponse) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{13}
}

func (x *StreamingRecognizeResponse) GetResults() []*StreamingRecognitionResult {
	if x != nil {
		return x.Results
	}
	return nil
}

func (x *StreamingRecognizeResponse) GetId() *RequestId {
	if x != nil {
		return x.Id
	}
	return nil
}

type PipelineStates struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Neural VAD probabilities
	VadProbabilities []float32 `protobuf:"fixed32,1,rep,packed,name=vad_probabilities,json=vadProbabilities,proto3" json:"vad_probabilities,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PipelineStates) Reset() {
	*x = PipelineStates{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PipelineStates) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PipelineStates) ProtoMessage() {}

func (x *PipelineStates) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PipelineStates.ProtoReflect.Descriptor instead.
func (*PipelineStates) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{14}
}

func (x *PipelineStates) GetVadProbabilities() []float32 {
	if x != nil {
		return x.VadProbabilities
	}
	return nil
}

// A streaming speech recognition result corresponding to a portion of the audio
// that is currently being processed.
type StreamingRecognitionResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// May contain one or more recognition hypotheses (up to the
	// maximum specified in `max_alternatives`).
	// These alternatives are ordered in terms of accuracy, with the top (first)
	// alternative being the most probable, as ranked by the recognizer.
	Alternatives []*SpeechRecognitionAlternative `protobuf:"bytes,1,rep,name=alternatives,proto3" json:"alternatives,omitempty"`
	// If `false`, this `StreamingRecognitionResult` represents an
	// interim result that may change. If `true`, this is the final time the
	// speech service will return this particular `StreamingRecognitionResult`,
	// the recognizer will not return any further hypotheses for this portion of
	// the transcript and corresponding audio.
	IsFinal bool `protobuf:"varint,2,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
	// An estimate of the likelihood that the recognizer will not
	// change its guess about this interim result. Values range from 0.0
	// (completely unstable) to 1.0 (completely stable).
	// This field is only provided for interim results (`is_final=false`).
	// The default of 0.0 is a sentinel value indicating `stability` was not set.
	Stability float32 `protobuf:"fixed32,3,opt,name=stability,proto3" json:"stability,omitempty"`
	// For multi-channel audio, this is the channel number corresponding to the
	// recognized result for the audio from that channel.
	// For audio_channel_count = N, its output values can range from '1' to 'N'.
	ChannelTag int32 `protobuf:"varint,5,opt,name=channel_tag,json=channelTag,proto3" json:"channel_tag,omitempty"`
	// Length of audio processed so far in seconds
	AudioProcessed float32 `protobuf:"fixed32,6,opt,name=audio_processed,json=audioProcessed,proto3" json:"audio_processed,omitempty"`
	// Message for pipeline states
	PipelineStates *PipelineStates `protobuf:"bytes,7,opt,name=pipeline_states,json=pipelineStates,proto3,oneof" json:"pipeline_states,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StreamingRecognitionResult) Reset() {
	*x = StreamingRecognitionResult{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StreamingRecognitionResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StreamingRecognitionResult) ProtoMessage() {}

func (x *StreamingRecognitionResult) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StreamingRecognitionResult.ProtoReflect.Descriptor instead.
func (*StreamingRecognitionResult) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{15}
}

func (x *StreamingRecognitionResult) GetAlternatives() []*SpeechRecognitionAlternative {
	if x != nil {
		return x.Alternatives
	}
	return nil
}

func (x *StreamingRecognitionResult) GetIsFinal() bool {
	if x != nil {
		return x.IsFinal
	}
	return false
}

func (x *StreamingRecognitionResult) GetStability() float32 {
	if x != nil {
		return x.Stability
	}
	return 0
}

func (x *StreamingRecognitionResult) GetChannelTag() int32 {
	if x != nil {
		return x.ChannelTag
	}
	return 0
}

func (x *StreamingRecognitionResult) GetAudioProcessed() float32 {
	if x != nil {
		return x.AudioProcessed
	}
	return 0
}

func (x *StreamingRecognitionResult) GetPipelineStates() *PipelineStates {
	if x != nil {
		return x.PipelineStates
	}
	return nil
}

type RivaSpeechRecognitionConfigResponse_Config struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ModelName     string                 `protobuf:"bytes,1,opt,name=model_name,json=modelName,proto3" json:"model_name,omitempty"`
	Parameters    map[string]string      `protobuf:"bytes,2,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RivaSpeechRecognitionConfigResponse_Config) Reset() {
	*x = RivaSpeechRecognitionConfigResponse_Config{}
	mi := &file_riva_proto_riva_asr_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RivaSpeechRecognitionConfigResponse_Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RivaSpeechRecognitionConfigResponse_Config) ProtoMessage() {}

func (x *RivaSpeechRecognitionConfigResponse_Config) ProtoReflect() protoreflect.Message {
	mi := &file_riva_proto_riva_asr_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RivaSpeechRecognitionConfigResponse_Config.ProtoReflect.Descriptor instead.
func (*RivaSpeechRecognitionConfigResponse_Config) Descriptor() ([]byte, []int) {
	return file_riva_proto_riva_asr_proto_rawDescGZIP(), []int{1, 0}
}

func (x *RivaSpeechRecognitionConfigResponse_Config) GetModelName() string {
	if x != nil {
		return x.ModelName
	}
	return ""
}

func (x *RivaSpeechRecognitionConfigResponse_Config) GetParameters() map[string]string {
	if x != nil {
		return x.Parameters
	}
	return nil
}

var File_riva_proto_riva_asr_proto protoreflect.FileDescriptor

var file_riva_proto_riva_asr_proto_rawDesc = string([]byte{
	0x0a, 0x19, 0x72, 0x69, 0x76, 0x61, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x72, 0x69, 0x76,
	0x61, 0x5f, 0x61, 0x73, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0f, 0x6e, 0x76, 0x69,
	0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x1a, 0x1b, 0x72, 0x69,
	0x76, 0x61, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x72, 0x69, 0x76, 0x61, 0x5f, 0x61, 0x75,
	0x64, 0x69, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1c, 0x72, 0x69, 0x76, 0x61, 0x2f,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x72, 0x69, 0x76, 0x61, 0x5f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f,
	0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x43, 0x0a, 0x22, 0x52, 0x69, 0x76, 0x61, 0x53,
	0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a,
	0x0a, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x09, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0xdb, 0x02, 0x0a,
	0x23, 0x52, 0x69, 0x76, 0x61, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67,
	0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x5e, 0x0a, 0x0c, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x63, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x6e, 0x76, 0x69,
	0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x52, 0x69, 0x76,
	0x61, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0b, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x43, 0x6f,
	0x6e, 0x66, 0x69, 0x67, 0x1a, 0xd3, 0x01, 0x0a, 0x06, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
	0x1d, 0x0a, 0x0a, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x09, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x6b,
	0x0a, 0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x4b, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61,
	0x2e, 0x61, 0x73, 0x72, 0x2e, 0x52, 0x69, 0x76, 0x61, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52,
	0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e,
	0x50, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,
	0x0a, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x1a, 0x3d, 0x0a, 0x0f, 0x50,
	0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
	0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
	0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x8c, 0x01, 0x0a, 0x10, 0x52,
	0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x3a, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x22, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73,
	0x72, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x14, 0x0a, 0x05, 0x61,
	0x75, 0x64, 0x69, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x61, 0x75, 0x64, 0x69,
	0x6f, 0x12, 0x26, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x64, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
	0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x49, 0x64, 0x52, 0x02, 0x69, 0x64, 0x22, 0xd9, 0x01, 0x0a, 0x19, 0x53, 0x74,
	0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x58, 0x0a, 0x10, 0x73, 0x74, 0x72, 0x65, 0x61,
	0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2b, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e,
	0x61, 0x73, 0x72, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63,
	0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00,
	0x52, 0x0f, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x25, 0x0a, 0x0d, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65,
	0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x0c, 0x61, 0x75, 0x64, 0x69,
	0x6f, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x12, 0x26, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x64,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69,
	0x76, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x52, 0x02, 0x69, 0x64,
	0x42, 0x13, 0x0a, 0x11, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x72, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x97, 0x03, 0x0a, 0x11, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69,
	0x6e, 0x74, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x28, 0x0a, 0x0d, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x5f, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x05, 0x48, 0x00, 0x52, 0x0c, 0x73, 0x74, 0x61, 0x72, 0x74, 0x48, 0x69, 0x73, 0x74, 0x6f,
	0x72, 0x79, 0x88, 0x01, 0x01, 0x12, 0x2c, 0x0a, 0x0f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74,
	0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x02, 0x48, 0x01,
	0x52, 0x0e, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64,
	0x88, 0x01, 0x01, 0x12, 0x26, 0x0a, 0x0c, 0x73, 0x74, 0x6f, 0x70, 0x5f, 0x68, 0x69, 0x73, 0x74,
	0x6f, 0x72, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x48, 0x02, 0x52, 0x0b, 0x73, 0x74, 0x6f,
	0x70, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x88, 0x01, 0x01, 0x12, 0x2a, 0x0a, 0x0e, 0x73,
	0x74, 0x6f, 0x70, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x02, 0x48, 0x03, 0x52, 0x0d, 0x73, 0x74, 0x6f, 0x70, 0x54, 0x68, 0x72, 0x65, 0x73,
	0x68, 0x6f, 0x6c, 0x64, 0x88, 0x01, 0x01, 0x12, 0x2d, 0x0a, 0x10, 0x73, 0x74, 0x6f, 0x70, 0x5f,
	0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x65, 0x6f, 0x75, 0x18, 0x05, 0x20, 0x01, 0x28,
	0x05, 0x48, 0x04, 0x52, 0x0e, 0x73, 0x74, 0x6f, 0x70, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79,
	0x45, 0x6f, 0x75, 0x88, 0x01, 0x01, 0x12, 0x31, 0x0a, 0x12, 0x73, 0x74, 0x6f, 0x70, 0x5f, 0x74,
	0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x5f, 0x65, 0x6f, 0x75, 0x18, 0x06, 0x20, 0x01,
	0x28, 0x02, 0x48, 0x05, 0x52, 0x10, 0x73, 0x74, 0x6f, 0x70, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68,
	0x6f, 0x6c, 0x64, 0x45, 0x6f, 0x75, 0x88, 0x01, 0x01, 0x42, 0x10, 0x0a, 0x0e, 0x5f, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x5f, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x42, 0x12, 0x0a, 0x10, 0x5f,
	0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x42,
	0x0f, 0x0a, 0x0d, 0x5f, 0x73, 0x74, 0x6f, 0x70, 0x5f, 0x68, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79,
	0x42, 0x11, 0x0a, 0x0f, 0x5f, 0x73, 0x74, 0x6f, 0x70, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68,
	0x6f, 0x6c, 0x64, 0x42, 0x13, 0x0a, 0x11, 0x5f, 0x73, 0x74, 0x6f, 0x70, 0x5f, 0x68, 0x69, 0x73,
	0x74, 0x6f, 0x72, 0x79, 0x5f, 0x65, 0x6f, 0x75, 0x42, 0x15, 0x0a, 0x13, 0x5f, 0x73, 0x74, 0x6f,
	0x70, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x5f, 0x65, 0x6f, 0x75, 0x22,
	0x86, 0x08, 0x0a, 0x11, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43,
	0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x36, 0x0a, 0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e,
	0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61,
	0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x41, 0x75, 0x64, 0x69, 0x6f, 0x45, 0x6e, 0x63, 0x6f, 0x64,
	0x69, 0x6e, 0x67, 0x52, 0x08, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x2a, 0x0a,
	0x11, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x68, 0x65, 0x72,
	0x74, 0x7a, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65,
	0x52, 0x61, 0x74, 0x65, 0x48, 0x65, 0x72, 0x74, 0x7a, 0x12, 0x23, 0x0a, 0x0d, 0x6c, 0x61, 0x6e,
	0x67, 0x75, 0x61, 0x67, 0x65, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x0c, 0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x12, 0x29,
	0x0a, 0x10, 0x6d, 0x61, 0x78, 0x5f, 0x61, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76,
	0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x41, 0x6c, 0x74,
	0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x12, 0x29, 0x0a, 0x10, 0x70, 0x72, 0x6f,
	0x66, 0x61, 0x6e, 0x69, 0x74, 0x79, 0x5f, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x08, 0x52, 0x0f, 0x70, 0x72, 0x6f, 0x66, 0x61, 0x6e, 0x69, 0x74, 0x79, 0x46, 0x69,
	0x6c, 0x74, 0x65, 0x72, 0x12, 0x47, 0x0a, 0x0f, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68, 0x5f, 0x63,
	0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e,
	0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e,
	0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x52, 0x0e, 0x73,
	0x70, 0x65, 0x65, 0x63, 0x68, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x73, 0x12, 0x2e, 0x0a,
	0x13, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f, 0x63,
	0x6f, 0x75, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x52, 0x11, 0x61, 0x75, 0x64, 0x69,
	0x6f, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x37, 0x0a,
	0x18, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x77, 0x6f, 0x72, 0x64, 0x5f, 0x74, 0x69, 0x6d,
	0x65, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x73, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x15, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x57, 0x6f, 0x72, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x4f,
	0x66, 0x66, 0x73, 0x65, 0x74, 0x73, 0x12, 0x40, 0x0a, 0x1c, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65,
	0x5f, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x5f, 0x70, 0x75, 0x6e, 0x63, 0x74,
	0x75, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x52, 0x1a, 0x65, 0x6e,
	0x61, 0x62, 0x6c, 0x65, 0x41, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x69, 0x63, 0x50, 0x75, 0x6e,
	0x63, 0x74, 0x75, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x54, 0x0a, 0x27, 0x65, 0x6e, 0x61, 0x62,
	0x6c, 0x65, 0x5f, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x63, 0x6f,
	0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x70, 0x65, 0x72, 0x5f, 0x63, 0x68, 0x61, 0x6e,
	0x6e, 0x65, 0x6c, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x52, 0x23, 0x65, 0x6e, 0x61, 0x62, 0x6c,
	0x65, 0x53, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x65, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x43, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x12, 0x14,
	0x0a, 0x05, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6d,
	0x6f, 0x64, 0x65, 0x6c, 0x12, 0x31, 0x0a, 0x14, 0x76, 0x65, 0x72, 0x62, 0x61, 0x74, 0x69, 0x6d,
	0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x73, 0x18, 0x0e, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x13, 0x76, 0x65, 0x72, 0x62, 0x61, 0x74, 0x69, 0x6d, 0x54, 0x72, 0x61, 0x6e,
	0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x73, 0x12, 0x58, 0x0a, 0x12, 0x64, 0x69, 0x61, 0x72, 0x69,
	0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x13, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76,
	0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x53, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x44, 0x69, 0x61,
	0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x11,
	0x64, 0x69, 0x61, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x12, 0x6e, 0x0a, 0x14, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x63, 0x6f, 0x6e, 0x66,
	0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x18, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x3b, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73,
	0x72, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x13, 0x63, 0x75,
	0x73, 0x74, 0x6f, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x12, 0x56, 0x0a, 0x12, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67,
	0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x19, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e,
	0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e,
	0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x48, 0x00, 0x52, 0x11, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e, 0x67,
	0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x88, 0x01, 0x01, 0x1a, 0x46, 0x0a, 0x18, 0x43, 0x75, 0x73,
	0x74, 0x6f, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38,
	0x01, 0x42, 0x15, 0x0a, 0x13, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x69, 0x6e,
	0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x22, 0x81, 0x01, 0x0a, 0x1a, 0x53, 0x74, 0x72,
	0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3a, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69,
	0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61,
	0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x06, 0x63, 0x6f, 0x6e,
	0x66, 0x69, 0x67, 0x12, 0x27, 0x0a, 0x0f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x69, 0x6d, 0x5f, 0x72,
	0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x69, 0x6e,
	0x74, 0x65, 0x72, 0x69, 0x6d, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x22, 0x84, 0x01, 0x0a,
	0x18, 0x53, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x44, 0x69, 0x61, 0x72, 0x69, 0x7a, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x3c, 0x0a, 0x1a, 0x65, 0x6e, 0x61,
	0x62, 0x6c, 0x65, 0x5f, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x64, 0x69, 0x61, 0x72,
	0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x18, 0x65,
	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x44, 0x69, 0x61, 0x72,
	0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x11, 0x6d, 0x61, 0x78, 0x5f, 0x73,
	0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x05, 0x52, 0x0f, 0x6d, 0x61, 0x78, 0x53, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x43, 0x6f,
	0x75, 0x6e, 0x74, 0x22, 0x3f, 0x0a, 0x0d, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x43, 0x6f, 0x6e,
	0x74, 0x65, 0x78, 0x74, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x70, 0x68, 0x72, 0x61, 0x73, 0x65, 0x73, 0x12, 0x14,
	0x0a, 0x05, 0x62, 0x6f, 0x6f, 0x73, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52, 0x05, 0x62,
	0x6f, 0x6f, 0x73, 0x74, 0x22, 0x7f, 0x0a, 0x11, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a,
	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x42, 0x0a, 0x07, 0x72, 0x65, 0x73,
	0x75, 0x6c, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x6e, 0x76, 0x69,
	0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x53, 0x70, 0x65,
	0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65,
	0x73, 0x75, 0x6c, 0x74, 0x52, 0x07, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x12, 0x26, 0x0a,
	0x02, 0x69, 0x64, 0x18, 0x64, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6e, 0x76, 0x69, 0x64,
	0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x49,
	0x64, 0x52, 0x02, 0x69, 0x64, 0x22, 0xb6, 0x01, 0x0a, 0x17, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c,
	0x74, 0x12, 0x51, 0x0a, 0x0c, 0x61, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61,
	0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x6c, 0x74, 0x65, 0x72,
	0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x52, 0x0c, 0x61, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74,
	0x69, 0x76, 0x65, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f,
	0x74, 0x61, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x54, 0x61, 0x67, 0x12, 0x27, 0x0a, 0x0f, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x70,
	0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0e,
	0x61, 0x75, 0x64, 0x69, 0x6f, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x22, 0x8f,
	0x01, 0x0a, 0x1c, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x12,
	0x1e, 0x0a, 0x0a, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x09, 0x52, 0x0a, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x12,
	0x1e, 0x0a, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x02, 0x52, 0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12,
	0x2f, 0x0a, 0x05, 0x77, 0x6f, 0x72, 0x64, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19,
	0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72,
	0x2e, 0x57, 0x6f, 0x72, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x05, 0x77, 0x6f, 0x72, 0x64, 0x73,
	0x22, 0x99, 0x01, 0x0a, 0x08, 0x57, 0x6f, 0x72, 0x64, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1d, 0x0a,
	0x0a, 0x73, 0x74, 0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x19, 0x0a, 0x08,
	0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07,
	0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x77, 0x6f, 0x72, 0x64, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x77, 0x6f, 0x72, 0x64, 0x12, 0x1e, 0x0a, 0x0a, 0x63,
	0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x02, 0x52,
	0x0a, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x64, 0x65, 0x6e, 0x63, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x73,
	0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x5f, 0x74, 0x61, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05,
	0x52, 0x0a, 0x73, 0x70, 0x65, 0x61, 0x6b, 0x65, 0x72, 0x54, 0x61, 0x67, 0x22, 0x8b, 0x01, 0x0a,
	0x1a, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e,
	0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x45, 0x0a, 0x07, 0x72,
	0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x6e,
	0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x53,
	0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x52, 0x07, 0x72, 0x65, 0x73, 0x75, 0x6c,
	0x74, 0x73, 0x12, 0x26, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x64, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16,
	0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x52, 0x65, 0x71,
	0x75, 0x65, 0x73, 0x74, 0x49, 0x64, 0x52, 0x02, 0x69, 0x64, 0x22, 0x3d, 0x0a, 0x0e, 0x50, 0x69,
	0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x12, 0x2b, 0x0a, 0x11,
	0x76, 0x61, 0x64, 0x5f, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x02, 0x52, 0x10, 0x76, 0x61, 0x64, 0x50, 0x72, 0x6f, 0x62,
	0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x69, 0x65, 0x73, 0x22, 0xd5, 0x02, 0x0a, 0x1a, 0x53, 0x74,
	0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x52, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x12, 0x51, 0x0a, 0x0c, 0x61, 0x6c, 0x74, 0x65,
	0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d,
	0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72,
	0x2e, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69,
	0x6f, 0x6e, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x52, 0x0c, 0x61,
	0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x69, 0x76, 0x65, 0x73, 0x12, 0x19, 0x0a, 0x08, 0x69,
	0x73, 0x5f, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x69,
	0x73, 0x46, 0x69, 0x6e, 0x61, 0x6c, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x62, 0x69, 0x6c,
	0x69, 0x74, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x52, 0x09, 0x73, 0x74, 0x61, 0x62, 0x69,
	0x6c, 0x69, 0x74, 0x79, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x68, 0x61, 0x6e, 0x6e, 0x65, 0x6c, 0x5f,
	0x74, 0x61, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x63, 0x68, 0x61, 0x6e, 0x6e,
	0x65, 0x6c, 0x54, 0x61, 0x67, 0x12, 0x27, 0x0a, 0x0f, 0x61, 0x75, 0x64, 0x69, 0x6f, 0x5f, 0x70,
	0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0e,
	0x61, 0x75, 0x64, 0x69, 0x6f, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x12, 0x4d,
	0x0a, 0x0f, 0x70, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65,
	0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61,
	0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x50, 0x69, 0x70, 0x65, 0x6c, 0x69,
	0x6e, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x48, 0x00, 0x52, 0x0e, 0x70, 0x69, 0x70, 0x65,
	0x6c, 0x69, 0x6e, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x88, 0x01, 0x01, 0x42, 0x12, 0x0a,
	0x10, 0x5f, 0x70, 0x69, 0x70, 0x65, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65,
	0x73, 0x32, 0xf2, 0x02, 0x0a, 0x15, 0x52, 0x69, 0x76, 0x61, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68,
	0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x54, 0x0a, 0x09, 0x52,
	0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x12, 0x21, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69,
	0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x52, 0x65, 0x63, 0x6f, 0x67,
	0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x6e, 0x76,
	0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x52, 0x65,
	0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
	0x00, 0x12, 0x73, 0x0a, 0x12, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52, 0x65,
	0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x12, 0x2a, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61,
	0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d,
	0x69, 0x6e, 0x67, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x71, 0x75,
	0x65, 0x73, 0x74, 0x1a, 0x2b, 0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76,
	0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x52,
	0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x7a, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x22, 0x00, 0x28, 0x01, 0x30, 0x01, 0x12, 0x8d, 0x01, 0x0a, 0x1e, 0x47, 0x65, 0x74, 0x52, 0x69,
	0x76, 0x61, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x33, 0x2e, 0x6e, 0x76, 0x69, 0x64,
	0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72, 0x2e, 0x52, 0x69, 0x76, 0x61,
	0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67, 0x6e, 0x69, 0x74, 0x69, 0x6f,
	0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x34,
	0x2e, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61, 0x2e, 0x72, 0x69, 0x76, 0x61, 0x2e, 0x61, 0x73, 0x72,
	0x2e, 0x52, 0x69, 0x76, 0x61, 0x53, 0x70, 0x65, 0x65, 0x63, 0x68, 0x52, 0x65, 0x63, 0x6f, 0x67,
	0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x00, 0x42, 0x1b, 0x5a, 0x16, 0x6e, 0x76, 0x69, 0x64, 0x69, 0x61,
	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x72, 0x69, 0x76, 0x61, 0x5f, 0x73, 0x70, 0x65, 0x65, 0x63, 0x68,
	0xf8, 0x01, 0x01, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
})

var (
	file_riva_proto_riva_asr_proto_rawDescOnce sync.Once
	file_riva_proto_riva_asr_proto_rawDescData []byte
)

func file_riva_proto_riva_asr_proto_rawDescGZIP() []byte {
	file_riva_proto_riva_asr_proto_rawDescOnce.Do(func() {
		file_riva_proto_riva_asr_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_riva_proto_riva_asr_proto_rawDesc), len(file_riva_proto_riva_asr_proto_rawDesc)))
	})
	return file_riva_proto_riva_asr_proto_rawDescData
}

var file_riva_proto_riva_asr_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
var file_riva_proto_riva_asr_proto_goTypes = []any{
	(*RivaSpeechRecognitionConfigRequest)(nil),         // 0: nvidia.riva.asr.RivaSpeechRecognitionConfigRequest
	(*RivaSpeechRecognitionConfigResponse)(nil),        // 1: nvidia.riva.asr.RivaSpeechRecognitionConfigResponse
	(*RecognizeRequest)(nil),                           // 2: nvidia.riva.asr.RecognizeRequest
	(*StreamingRecognizeRequest)(nil),                  // 3: nvidia.riva.asr.StreamingRecognizeRequest
	(*EndpointingConfig)(nil),                          // 4: nvidia.riva.asr.EndpointingConfig
	(*RecognitionConfig)(nil),                          // 5: nvidia.riva.asr.RecognitionConfig
	(*StreamingRecognitionConfig)(nil),                 // 6: nvidia.riva.asr.StreamingRecognitionConfig
	(*SpeakerDiarizationConfig)(nil),                   // 7: nvidia.riva.asr.SpeakerDiarizationConfig
	(*SpeechContext)(nil),                              // 8: nvidia.riva.asr.SpeechContext
	(*RecognizeResponse)(nil),                          // 9: nvidia.riva.asr.RecognizeResponse
	(*SpeechRecognitionResult)(nil),                    // 10: nvidia.riva.asr.SpeechRecognitionResult
	(*SpeechRecognitionAlternative)(nil),               // 11: nvidia.riva.asr.SpeechRecognitionAlternative
	(*WordInfo)(nil),                                   // 12: nvidia.riva.asr.WordInfo
	(*StreamingRecognizeResponse)(nil),                 // 13: nvidia.riva.asr.StreamingRecognizeResponse
	(*PipelineStates)(nil),                             // 14: nvidia.riva.asr.PipelineStates
	(*StreamingRecognitionResult)(nil),                 // 15: nvidia.riva.asr.StreamingRecognitionResult
	(*RivaSpeechRecognitionConfigResponse_Config)(nil), // 16: nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config
	nil,                // 17: nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.ParametersEntry
	nil,                // 18: nvidia.riva.asr.RecognitionConfig.CustomConfigurationEntry
	(*RequestId)(nil),  // 19: nvidia.riva.RequestId
	(AudioEncoding)(0), // 20: nvidia.riva.AudioEncoding
}
var file_riva_proto_riva_asr_proto_depIdxs = []int32{
	16, // 0: nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.model_config:type_name -> nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config
	5,  // 1: nvidia.riva.asr.RecognizeRequest.config:type_name -> nvidia.riva.asr.RecognitionConfig
	19, // 2: nvidia.riva.asr.RecognizeRequest.id:type_name -> nvidia.riva.RequestId
	6,  // 3: nvidia.riva.asr.StreamingRecognizeRequest.streaming_config:type_name -> nvidia.riva.asr.StreamingRecognitionConfig
	19, // 4: nvidia.riva.asr.StreamingRecognizeRequest.id:type_name -> nvidia.riva.RequestId
	20, // 5: nvidia.riva.asr.RecognitionConfig.encoding:type_name -> nvidia.riva.AudioEncoding
	8,  // 6: nvidia.riva.asr.RecognitionConfig.speech_contexts:type_name -> nvidia.riva.asr.SpeechContext
	7,  // 7: nvidia.riva.asr.RecognitionConfig.diarization_config:type_name -> nvidia.riva.asr.SpeakerDiarizationConfig
	18, // 8: nvidia.riva.asr.RecognitionConfig.custom_configuration:type_name -> nvidia.riva.asr.RecognitionConfig.CustomConfigurationEntry
	4,  // 9: nvidia.riva.asr.RecognitionConfig.endpointing_config:type_name -> nvidia.riva.asr.EndpointingConfig
	5,  // 10: nvidia.riva.asr.StreamingRecognitionConfig.config:type_name -> nvidia.riva.asr.RecognitionConfig
	10, // 11: nvidia.riva.asr.RecognizeResponse.results:type_name -> nvidia.riva.asr.SpeechRecognitionResult
	19, // 12: nvidia.riva.asr.RecognizeResponse.id:type_name -> nvidia.riva.RequestId
	11, // 13: nvidia.riva.asr.SpeechRecognitionResult.alternatives:type_name -> nvidia.riva.asr.SpeechRecognitionAlternative
	12, // 14: nvidia.riva.asr.SpeechRecognitionAlternative.words:type_name -> nvidia.riva.asr.WordInfo
	15, // 15: nvidia.riva.asr.StreamingRecognizeResponse.results:type_name -> nvidia.riva.asr.StreamingRecognitionResult
	19, // 16: nvidia.riva.asr.StreamingRecognizeResponse.id:type_name -> nvidia.riva.RequestId
	11, // 17: nvidia.riva.asr.StreamingRecognitionResult.alternatives:type_name -> nvidia.riva.asr.SpeechRecognitionAlternative
	14, // 18: nvidia.riva.asr.StreamingRecognitionResult.pipeline_states:type_name -> nvidia.riva.asr.PipelineStates
	17, // 19: nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.parameters:type_name -> nvidia.riva.asr.RivaSpeechRecognitionConfigResponse.Config.ParametersEntry
	2,  // 20: nvidia.riva.asr.RivaSpeechRecognition.Recognize:input_type -> nvidia.riva.asr.RecognizeRequest
	3,  // 21: nvidia.riva.asr.RivaSpeechRecognition.StreamingRecognize:input_type -> nvidia.riva.asr.StreamingRecognizeRequest
	0,  // 22: nvidia.riva.asr.RivaSpeechRecognition.GetRivaSpeechRecognitionConfig:input_type -> nvidia.riva.asr.RivaSpeechRecognitionConfigRequest
	9,  // 23: nvidia.riva.asr.RivaSpeechRecognition.Recognize:output_type -> nvidia.riva.asr.RecognizeResponse
	13, // 24: nvidia.riva.asr.RivaSpeechRecognition.StreamingRecognize:output_type -> nvidia.riva.asr.StreamingRecognizeResponse
	1,  // 25: nvidia.riva.asr.RivaSpeechRecognition.GetRivaSpeechRecognitionConfig:output_type -> nvidia.riva.asr.RivaSpeechRecognitionConfigResponse
	23, // [23:26] is the sub-list for method output_type
	20, // [20:23] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_riva_proto_riva_asr_proto_init() }
func file_riva_proto_riva_asr_proto_init() {
	if File_riva_proto_riva_asr_proto != nil {
		return
	}
	file_riva_proto_riva_audio_proto_init()
	file_riva_proto_riva_common_proto_init()
	file_riva_proto_riva_asr_proto_msgTypes[3].OneofWrappers = []any{
		(*StreamingRecognizeRequest_StreamingConfig)(nil),
		(*StreamingRecognizeRequest_AudioContent)(nil),
	}
	file_riva_proto_riva_asr_proto_msgTypes[4].OneofWrappers = []any{}
	file_riva_proto_riva_asr_proto_msgTypes[5].OneofWrappers = []any{}
	file_riva_proto_riva_asr_proto_msgTypes[15].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_riva_proto_riva_asr_proto_rawDesc), len(file_riva_proto_riva_asr_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   19,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_riva_proto_riva_asr_proto_goTypes,
		DependencyIndexes: file_riva_proto_riva_asr_proto_depIdxs,
		MessageInfos:      file_riva_proto_riva_asr_proto_msgTypes,
	}.Build()
	File_riva_proto_riva_asr_proto = out.File
	file_riva_proto_riva_asr_proto_goTypes = nil
	file_riva_proto_riva_asr_proto_depIdxs = nil
}
